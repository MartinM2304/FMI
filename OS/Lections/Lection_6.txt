ако има race condition  върху lock
се прави test_and_set

виж в google test_and_set, spinlock, dis-int/end_int

dis_int- това е за прекъсването
test_and_set R,lock
if R=1 goto spinlock //Това е проблемно защото другия цикъл върти напразно,
// по добре е ако има прекъсване другия процес да изпълни критичната секция
// Затова е по добре да го направим така:
//	if R=0 goto CR
//	end_int
//	goto spinlock

критична секция: CR
.
.
.
st 0, lock
end_int - това е за прекъсванията

обаче това има недостатъци!
Ако 1 процес се добере до тази секция, всички други чакат да се освободи тази секция.
Те циклят безмислено, затова трябва Критичните секции да се изпълняват БЪРЗО !!!

Когато изпълняваме критична секция, трябва да ЗАБРАНИМ прекъсването!

В КРИТИЧНАТА ЧАСТ НЕ ТРЯБВА ДА ИМА ФУНКЦИИ КОИТО ВИКАТ lock


Има решение за да не въртим излишно. Вместо да въртят цикъл дадени процеси, те
спират да позлват процесорното време и го дават на други процеси които може да няматю
нищо общо с останалите процеси.
Един процес трябва да може да се откаже от процесорното си време докато няма възможност
да работи.- Sleeping proccesses.

КОМАНДАТА top- показва всички процеси, където в Task пише общ брой процеси, running ,
спящи,stopped, zombie процеси.

2 функции променят процеса- block()- процеса заявява на ядрото, не мога да си свърша работат,
защото други процеси не ми дават и искам да бъда приспан. Ядрото запомня неговите данни и го 
приспива.
Тогава ядрото на същия процесор, слага друг процес да се изпълнява. ТОВА СЕ НАРИЧА СМЯНА НА 
КОНТЕКСТ.

ОБРАТНАТА операция е събуждане- wakeup(p_id)- процесът който ще напуска критичната си секция
знае кой процес чака да използва ресурса и той го буди.

Семафори- чети книгата до 100-на страница
семафор- int, //споделен обект

Събужда се най рано приспания процес
sem
init(cnt0)
wait()
signal()


